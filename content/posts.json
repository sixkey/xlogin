{"posts": {"snip-hunters": {"title": "Hunters", "content": [{"type": "p", "text": "In this snippet, I am evolving simple agents for object finding. New version @@snip-hunters2@@.", "title": null, "collaps": false, "show": false}, {"title": "Description", "content": [{"type": "p", "text": "At the start, you will experience a severe lag, this is caused by a lot of \"food\" being spawned at the start, so there is overpopulation. The overpopulation leads to a bigger gene pool. It will go away after a while.\nIf you fail to see any improvements, restart the simulation. From the tests I have run, a noticeable improvement should arrive at around generation 20-30 (number in the top-left corner, note that the number may go up and down as it represents the \"oldest\" cell, if it dies, the number may go down) but it may arrive earlier.\nThe reason for unpredictable results:"}, {"type": "ol", "items": ["There is only one hidden layer in hunters' neural network", "It is optimized only through mutation upon creation", "The constants are not set in an optimal manner", "Genetic drift (If only one cell survives, there will likely be food to support its offspring no matter its quality)"]}, {"type": "p", "text": "If you want to hide the lines, you can press the spacebar."}], "type": "container", "collaps": true, "show": false}, {"type": "p", "text": "I decided to rewrite the majority of @@spool@@, and I am currently working on math. Spool is mainly a small prototyping library and thus I am focusing mainly on the ease of use rather than on optimizing. I have decided that the main number container will be a new Tensor object that will be used for vectors, matrices, points, rectangles, polygons, etc. An interesting test for a tensor library is an implementation of a dense neural network.  ", "title": "Motivation", "collaps": true, "show": false}, {"title": "Neurons", "content": [{"type": "p", "text": "Each neuron outputs a value that is the result of applying an activation function to its inputs. In the majority of cases, it is a weighted sum of inputs. "}, {"type": "latex", "items": ["a = \\sum_{j=0}^{|i|} i^jw^j"]}, {"type": "p", "text": "Note that in %%i^j%% j is not power but the superscript. I am reserving subscripts for layer indexes.\nAdditionally, neurons usually have a constant that is added to the weighted sum called bias here as constant %%b%%."}, {"type": "latex", "items": ["a = \\sum_{j=0}^{|i|} i^jw^j + b"]}, {"type": "p", "text": "The final step is adding an activation function, in my case a sigmoid function."}, {"type": "latex", "items": ["\\sigma(x) = \\frac{1}{1 + e^{-x}}"]}, {"type": "p", "text": "The final neuron output is calculated like so:"}, {"type": "latex", "items": ["a = \\sigma(\\sum_{j=0}^{|i|} i^jw^j + b)"]}], "type": "container", "collaps": true, "show": false}, {"title": "Dense neural networks", "content": [{"type": "p", "text": "DNN is an artificial neural network composed of only dense layers, layers of neurons that are fully connected (their neighboring layers resemble a complete bipartite graph). Here is the calculation of the output value of %%k%%th neuron in layer %%a_l%%."}, {"type": "latex", "items": ["a_l^k = \\sigma\\Big(\\sum_{j=0}^{m}a_{l - 1}^jw_{l - 1}^{j,k} + b_l^k\\Big)"]}, {"type": "p", "text": "%%a_l^k%% - the kth neuron's output value in layer %%a_l%% where %%a_l%% are the %%l%%th layer's output values represented as a row vector.\n%%w_{l - 1}^{j,k}%% - the weight of connection between %%j%%th neuron from layer %%a_{l-1}%% and %%k%%th neuron from layer %%a_{l}%%.\n%%b_l^k%% - the bias of %%k%%th neuron's from layer %%a_{l}%%.\n%%m%% - the size of layer %%a_{l-1}%%.", "alignment": "center"}, {"type": "p", "text": "The main idea behind a dnn is that if you have layer %%a_{l-1}%% and layer %%a_l%%, they are fully connected, and thus there are %%|a_{l-1}|\\times|a_l|%% connections present between them. You can represent these connections by a %%|a_{l-1}|\\times|a_l|%% weights matrix in which each value represents how \"important\" one of the connections is. In my case, the value in %%j%%th row and %%k%%th column represents how much does %%j%%th neuron from %%a_{l-1}%% influences %%k%%th neurons in layer %%a_l%%. "}, {"type": "latex", "items": ["w_l = \\begin{pmatrix} w_l^{0,0} & w_l^{0,1} & \\cdots & w_l^{1,n} \\\\ w_l^{1,0} & w_l^{1,1} & \\cdots & w_l^{2,n} \\\\ \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\ w_l^{m,0} & w_l^{m,1} & \\cdots & w_l^{m,n} \\end{pmatrix}"]}, {"type": "p", "text": "%%w_l%% - weights matrix that connects layer %%a_l%% to layer %%a_{l + 1}%%\n%%m = |a_{l-1}|%% - 1\n%%n = |a_{l}|%% - 1", "alignment": "center"}, {"type": "p", "text": "The main benefit of this orientation is in forwarding, a process in which you calculate the values of layer %%a_l%% based on the values of layer %%a_{l-1}%%. If you represent information on layer %%a_{l-1}%% as a one by %%|a_{l-1}|%% size matrix (matrix with one row and %%|a_{l-1}|%% columns, a row vector), the values of neurons on layer %%a_l%% are just activation function applied to the sum of bias matrix %%b_l%% and the dot product of layer %%a_{l-1}%% and weights matrix %%w_{l-1}%%."}, {"type": "latex", "items": ["a_l = \\sigma\\Big(a_{l - 1} \\cdot w_{l - 1} + b_{l}\\Big)"]}, {"type": "p", "text": "%%a_l%% - output values of %%l%%th layer in the shape of a row vector.\n%%w_{l - 1}%% - weights matrix connecting layer %%a_{l - 1}%% and layer %%a_{l}%%\n%%b_{l}%% - bias vector of layer %%a_l%% \n%%\\sigma%% - activation function (in my case sigmoid)", "alignment": "center"}], "type": "container", "collaps": true, "show": false}, {"type": "p", "text": "A hunter is a simple agent that needs energy to function. The moment his energy goes below zero, he \"dies\". \nAll his calculations are done by internal dnn that takes input from its eyes and returns one output that corresponds to the steering angle.\nEach tick, energy (sum of a constant and the steering angle) is subtracted from its internal energy counter. The moment this energy counter goes below, it \"dies\". If the agent collides with food, it absorbs its energy and divides (natural selection). The newly created offspring mutates upon creation to produce a small change to the weights and biases matrixes (reproduction).\n", "title": "Hunter", "collaps": true, "show": false}], "collaps": false, "show": false, "wordCount": 886, "key": "snip-hunters", "languages": ["spool", "js"], "hashtags": ["js", "spool", "snippet", "hunters"], "date": "12-03-2020", "section": "snippets"}, "clunk": {"title": "Clunk", "content": [{"type": "p", "text": "Clunk is a CPP graphic application engine based on @@Hazel|https://github.com/TheCherno/Hazel@@. Currently, it supports OpenGL via GLAD and GLFW. For the UI it uses ImGui.\nFor me, clunk was a great way of learning some more advanced concepts of CPP and basics about graphics (shaders, etc.). Because this was a learning experience, a lot of the code is inherited from Hazel. I made some alterations in the event-handling system, introduced new primitives into 2D renderer and a simple ECS system based on @@this|https://austinmorlan.com/posts/entity_component_system/@@ post. I've also created some pre-made ECS systems for collision detection, very simple rendering, flocking behavior, and more.", "title": "Introduction", "collaps": false, "show": false}, {"title": "Little projects", "content": [{"type": "p", "text": "Clunk has an implementation of a @@quadtree system|https://en.wikipedia.org/wiki/Quadtree#:~:text=A%20quadtree%20is%20a%20tree,into%20four%20quadrants%20or%20regions.@@. Even though chunk segmentation would be probably fine, I wanted to try something different.\nThis quadtree is used in a quadtree system. The system provides the quadtree with information about the entities via forwarding their transform component and in exchange, it provides our ECS coordinator with the ability to quickly find entities in an area.", "title": "Quadtree", "collaps": false, "show": false}, {"type": "p", "text": "I.e. a very simple implementation of 2D gravity. Every time I start doing graphics, I try the basics out by simulating the creation of a solar system. The idea is simple. You create a bunch of particles and let @@Newton's gravity equation|Newton's gravity equation@@ do its thing. Even though clunk isn't the most optimized engine, it is capable of simulating thousands of particles in real-time thanks to batch renderer from Hazel and a quadtree system. \n::gravity|/images/clunk-gravity.gif|Gravity simulation|400::\nNote: the simulation is cutting corners by ignoring planets that are too far away to cause any real force.", "title": "PhysicsSystem (Gravity)", "collaps": false, "show": false}, {"type": "p", "text": "@@Boids|https://en.wikipedia.org/wiki/Boids@@ is a simple flocking simulation based on three rules: separation, alignment, and cohesion. Implementing such a system is easy, thanks to the previously mentioned ECS.\n::boids|/images/clunk-boids.gif|Boids|400::", "title": "Boids", "collaps": false, "show": false}, {"title": "Unsupervised learning", "content": [{"type": "p", "text": "By using, perhaps the most simple unsupervised learning model - @@GA|https://en.wikipedia.org/wiki/Genetic_algorithm@@, I've created a simple evolution simulation. The \"organism\" we are trying to optimize is a simple \"cell\". ", "title": null, "collaps": false, "show": false}, {"type": "p", "text": "Our cell is a 2d agent capable of simple sight, information processing, and movement. Sight is provided via an array of rays. Rays are just evenly spread lines, going from the center outwards with a finite size (vision constant). If a ray collides with an object, the percentage of the line between the start and the collision point is sent to the cell's input port in its processing unit. \nCell's information processing is done in a dense neural network. The size and number of hidden layers are defined in the cell's DNN component, so they are constants and not part of the evolution. DNN contains one input for every eye and a single output.\nThis output is connected to the cell's steering. Cells move with a constant velocity and control only their movement's steering. Each tick, the output from the DNN is added to the cells steering angle.", "title": "Cell", "collaps": false, "show": false}, {"title": "Genetic algorithm", "content": [{"type": "p", "text": "The machine learning algorithm I used is perhaps the most simple unsupervised model, @@GA|https://en.wikipedia.org/wiki/Genetic_algorithm@@. In our case, the genome is defined as an array of chromosomes in which each chromosome represents either DNN's weights or a biases matrix compressed into a vector. The act of reproduction is only a process of copying the genome and applying mutation function to each chromosome where mutation function is a function that alters each value in the chromosome slightly.\nHere are rules that provide natural selection:"}, {"type": "ol", "items": ["Each tick, each cell's energy is subtracted", "If a cell eats food, it produces offspring, and energy is added", "If a cell's energy hits zero, the cell dies"]}, {"type": "p", "text": "These simple rules together with a DNN is enough to produce cells that are *relatively* capable of finding food.\n::cells|/images/clunk-ga-2.gif|Cells|500::\n"}], "type": "container", "collaps": false, "show": false}], "type": "container", "collaps": false, "show": false}], "type": "container", "collaps": false, "show": false}], "collaps": false, "show": false, "wordCount": 608, "key": "clunk", "languages": ["cpp"], "hashtags": ["clunk", "cpp", "engine", "opengl", "glfw", "glew", "graphics", "gravity", "boids", "dnn", "neuralnetwork", "cell"], "date": "09-01-2020", "section": "main"}, "spool": {"title": "Spool", "content": [{"type": "p", "text": "Spool is a framework build on node.js, express and socket.io. It is made for hacking together simple .io style multiplayer games. The majority of code was build in one all-nighter so it lacks some important multiplayer features like client-side predictions.\n\nmore coming soon, some info @@here|https://github.com/inkontext/spool/wiki@@\n", "title": "Introduction", "collaps": true, "show": true}], "collaps": false, "show": false, "wordCount": 49, "key": "spool", "languages": ["node", "js", "socket.io"], "hashtags": ["spool", "node", "js", "socketio", "multiplayer", "gamedev"], "date": "09-01-2020", "section": "comingsoon"}, "cah": {"title": "Cards and Hexagons", "content": [{"type": "p", "text": "Cards and Hexagons is a turned based card game created using spool.\n\nmore coming soon\n", "title": "Introduction", "collaps": true, "show": true}], "collaps": false, "show": false, "wordCount": 18, "key": "cah", "languages": ["node", "js", "express", "socket.io", "spool"], "hashtags": ["node", "js", "express", "socketio", "spool", "multiplayer"], "date": "09-01-2020", "section": "comingsoon"}, "axiol": {"title": "Axiol", "content": [{"type": "p", "text": "Axiol is a social media network that focuses on graphical connection based posting.\n\nmore coming soon\n\n", "title": "Introduction", "collaps": false, "show": false}], "collaps": false, "show": false, "wordCount": 19, "key": "axiol", "languages": ["mern", "mongo", "express", "react", "node", "js"], "hashtags": ["axiol", "mern", "mongo", "express", "react", "node", "js", "html", "css"], "date": "09-01-2020", "section": "comingsoon"}, "snip-astar": {"title": "A*", "content": [{"type": "p", "text": "In this snippet I've implemented simple @@A* algorithm|https://en.wikipedia.org/wiki/A*_search_algorithm@@. I've introduced graphs and collections (currently only Heap) to @@spool@@.\n"}], "collaps": false, "show": false, "wordCount": 18, "key": "snip-astar", "languages": ["spool", "js"], "hashtags": ["js", "spool", "snippet", "astar", "pathfinding", "graphs"], "date": "1-24-2021", "section": "snippets"}, "lebac": {"title": "Lebac", "content": [{"type": "p", "text": "Lebac is a co-op puzzle game created with @@spool|/posts/spool@@.\n\nmore coming soon\n", "title": "Introduction", "collaps": true, "show": true}], "collaps": false, "show": false, "wordCount": 15, "key": "lebac", "languages": ["node", "js", "express", "socket.io", "spool"], "hashtags": ["node", "js", "express", "socketio", "spool", "multiplayer"], "date": "09-01-2020", "section": "comingsoon"}, "trevo": {"title": "Trevo", "content": [{"type": "p", "text": "Trevo is an evolution simulation made in @@sixgen@@, that focuses on optimizing 2D tree-like structures for ideal energy input and output.", "title": "Introduction", "collaps": false, "show": false}, {"title": "Development", "content": [{"type": "p", "text": "I started developing Trevo in the winter of 2016 and worked on it on and off for about two years. ", "title": null, "collaps": false, "show": false}, {"type": "p", "text": "::firstversion|images/trevo-ver10.png|4.11.2016: Version 0.1.0|300::\n::secondversion|images/trevo-ver11.png|15.12.2016: Version 0.1.1|300:: \n::thirdversion|images/trevo-ver13.png|1.1.2017: Version 0.1.3|300:: \n::fourthversion|images/trevo-ver15.png|7.1.2017: Version 0.1.5|300::", "title": "Different versions of trevo", "collaps": false, "show": false}, {"type": "p", "text": "Thanks to the my computer science teacher, we've registered Trevo for @@FVAT|https://www.festivalvedy.sk/wp2/@@. \nTrevo was a success at the regional level moved into the national round from which it was sent to EUCYS 2018 in Dublin. Even though it didn't receive one of the main prizes, It received a donated prize from @@PRACE|https://prace-ri.eu/@@.\n::posters|images/trevo-posters.png|Trevo's posters from EUCYS|::", "title": "FVAT", "collaps": false, "show": false}], "type": "container", "collaps": true, "show": false}, {"title": "Trevo", "content": [{"type": "p", "text": "Trevo is written in Java and uses @@sixgen@@, our Java-based game engine. ", "title": "SixGen", "collaps": false, "show": false}, {"type": "p", "text": "Trevo is mainly about visualizing GA by optimizing 2D geometry.  ", "title": "Main concept", "collaps": false, "show": false}, {"title": "Trees", "content": [{"type": "p", "text": "In Trevo, we are representing trees as 2D structures made out of vertices and their connections (branches). Each vertex that doesn't have any children becomes a leaf. Trees are procedurally generated from their genome.", "title": null, "collaps": false, "show": false}, {"type": "p", "text": "The genome of a tree is represented as a single chromosome, I.e. a simple array of integers. Each value in the array corresponds to some trait of the tree. \n::chromosome|images/trevo-chromosome.png|Indexed genes and traits they describe|400::\nThe majority of genes come in pairs. Each pair represents a range of possible values from which the real value is picked.", "title": "Genome", "collaps": false, "show": false}, {"title": "Procedural generation", "content": [{"type": "p", "text": "Trees are generated from their genome by the following algorithm:"}, {"type": "ol", "items": ["Add a root vertex", "Create a stem by extruding the root vertex", "Take a vertex from the queue", "If the depth (distance in graph to the root) of the vertex is smaller than the max level (written in the gene), create branches and add their ends to the queue, else add to the list of leaves", "Jump to part 3 if the queue is not empty"]}], "type": "container", "collaps": false, "show": false}, {"title": "Genetic algorithm", "content": [{"type": "p", "text": "Evolution is based on three main principles: natural selection, reproduction, and genetic drift. The last part is somewhat nondesirable because it brings regression and stagnation to small populations. For that reason, I've implemented only the first two principles.", "title": null, "collaps": false, "show": false}, {"type": "p", "text": "In our case, we opted for selection via a fitness function. Our fitness function simulates one moment of \"sunlight\" and calculates the trees energy IO coefficient. Two trees with the highest fitness values are first copied to the new generation to avoid any regression and then bred to fill out the population to the original size. The previous generation is discarded. ", "title": "Natural selection", "collaps": false, "show": false}, {"title": "Fitness function", "content": [{"type": "p", "text": "In Trevo, fitness is determined by the energy IO coefficient. \nFirst, we calculate the energy input by multiplying the number of live leaves by a leaf's energy per tick constant. To determine which leaves are \"alive\" we: "}, {"type": "ol", "items": ["look if the leaf is not below the \"herbivore level\" (a height reachable by virtual animals)", "look at any collision with nearby leaves.", "cast a ray going from the leaf \"up\" and look for a collision with any other branch"]}, {"type": "p", "text": "If the leaf is below the \"herbivore level\" or there is a collision, it is dead and thus ignored in calculating energy input.  \nSecond, we calculate the energy output by adding together the lengths of branches and multiply the sum by the consumption constant.\nLast, we divide the input by the output and have our fitness.\nHere is fitness function written as %%f(B, L)%% where %%B%% is the list of branches, %%L%% is the list of leaves, %%E_{in}%% is the energy input constant and %%E_{out} %% is the energy output constant."}, {"type": "latex", "items": ["f(B, L)=\\frac{E_{in} \\cdot \\sum_{i=0}^{|L|-1}alive(L_i)}{1 + E_{out} \\cdot \\sum_{i=0}^{|B|-1}length(B_i)}"]}, {"type": "latex", "items": ["alive(l)= \\begin{cases} 1& \\text{if l is alive} \\\\ 0& \\text{otherwise} \\end{cases}"]}], "type": "container", "collaps": false, "show": false}, {"title": "Reproduction", "content": [{"type": "p", "text": "In our case, every tree has only one chromosome with a fixed size of genes, so reproduction is relatively easy. "}, {"type": "ol", "items": ["You take two individuals", "For every chromosome in parent A you take the corresponding chromosome in parent B and apply a crossover function", "You apply mutation function to every newly created chromosome."]}], "type": "container", "collaps": false, "show": false}, {"title": "Crossover function", "content": [{"type": "p", "text": "The point of the crossover function is to create a new chromosome by combining two or more chromosomes. If you have two chromosomes with the same size, you will generate a new chromosome of the same size where for every gene in the chromosome, %%C_i = A_i%% or %%C_i = B_i%% where %%C%% is the offspring chromosome and both %%A%% and %%B%% are the chromosome of its parents.\nThe simplest approach is picking the parent from which the gene is, for every gene randomly. This approach is not optimal for keeping long strings of genes from a parent."}, {"type": "latex", "items": ["C_i = \\begin{cases} A_i& R_i = 1 \\\\ B_i& \\text{othwerise} \\end{cases}"]}, {"type": "p", "text": "%%R%% is a pseudo-random sequence of ones and zeroes with the same length as %%A%% and %%B%%", "alignment": "center"}, {"type": "p", "text": "For chromosomes with traits defined by long gene-blocks, there is an actual crossing method. In this method, you generate N unique crossing points, in which you switch between the parents. "}, {"type": "latex", "items": ["C_i = \\begin{cases} A_i& \\Big\\vert\\big\\lbrace p \\bigm\\vert p\\in P \\land p <= i \\big\\rbrace\\Big\\vert \\mod 2 = 1 \\\\ B_i& \\text{otherwise} \\end{cases}"]}, {"type": "p", "text": "%%P%% is a set of crossing points", "alignment": "center"}], "type": "container", "collaps": false, "show": false}, {"title": "Mutation function", "content": [{"type": "p", "text": "Mutation function is a function that alters chromosomes slightly.  \nFirst solution is to alter every element of the chromosome slightly."}, {"type": "latex", "items": ["G_i = m(C_i)"]}, {"type": "p", "text": "%%m%% is a mutation function", "alignment": "center"}, {"type": "p", "text": "Second is to only pick N random values and mutate only them."}, {"type": "latex", "items": ["G_i = \\begin{cases} m(C_i)& i \\in P \\\\ C_i& \\text{otherwise} \\end{cases}"]}, {"type": "p", "text": "%%m%% is a mutation function and %%P%% is a set of indexes we want to mutate", "alignment": "center"}, {"type": "p", "text": "\n"}], "type": "container", "collaps": false, "show": false}], "type": "container", "collaps": false, "show": false}], "type": "container", "collaps": false, "show": false}], "type": "container", "collaps": true, "show": false}, {"title": "Trevo in action", "content": [{"title": "Screens", "content": [{"title": "Main screen", "content": [{"type": "p", "text": "The main screen contains the evolution simulation. On the left, there is a panel with the mutation rates for different genes, on the right, there are minimum requirements, history settings, and a speed slider, and on the top, there is the main navigation.\n::mainscreen|images/trevo-mainscreen.png|Main screen|300::", "title": null, "collaps": false, "show": false}, {"type": "p", "text": "This example demonstrates trees' capability of adapting to animals. The rising red bar is the \"herbivore level\" I.e. the rising minimum y-coordinate that the leaf has to have for it to survive.\n::trevoinaction|images/trevo-inaction.gif|Adaptation to animals|400::", "title": "Response to animals", "collaps": false, "show": false}], "type": "container", "collaps": false, "show": false}, {"type": "p", "text": "Each individual that breaks the fitness record is automatically inserted into history, but trees can be also saved manually or periodically from the main screen. \n::history|images/trevo-comparison.png|History screen|300::\nIn some cases, trees with lower average fitness can win in a \"forest\" setting. Usually, this happens between a tree-like plant and a grass-like plant. The \"tree\" has a taller body and thus a higher energy consumption and lower fitness. The reason it still wins is that its higher positioned branches cast a \"shadow\" on the lower situated leaves below, removing the grass-like plant's source of energy and thus lowering its fitness.\n::duel|images/trevo-duel.png|Duel|300::\nIn default, Trevo treats every tree as a structure in a vacuum. If you want to enable global shadow checking, you can turn it on by toggling the 'Check with world' switch on the main screen.", "title": "History", "collaps": false, "show": false}, {"type": "p", "text": "If you are interested in the genome analysis of a plant, you can visit the genome analysis screen.\nOn the left, there are the gene values and the traits they represent. In the center, there are three possible products of the generation function with the currently analyzed genome as an argument. The plant on the very right is the original owner of the genome. \nThe values above the plants are their fitness value. \n::genome|images/trevo-genome.png|Genome analysis screen|300::", "title": "Genome analysis", "collaps": false, "show": false}], "type": "container", "collaps": false, "show": false}], "type": "container", "collaps": true, "show": false}, {"type": "p", "text": "The majority of limitation features were added to make the structures look like actual trees. When you look at the fitness function, you'll quickly realize that one way of maximizing fitness is minimizing the denominator, I.e. the body size. Thus every simulation without limitations results in a population of grass. To get rid of this problem I first played around with the energy constants then added minimal requirements, and finally introduced \"herbivores.\" \nBecause of this struggle, I use the word tree and the word plant interchangeably. Technically Trevo is capable of creating structures that resemble other plants, thus calling them trees wouldn't be general enough, but at a mathematical level, they are still tree graphs, so it's ok.", "title": "Final words", "collaps": true, "show": false}, {"title": "Downloads", "content": [{"type": "downloads", "items": ["downloads/trevo.jar|Trevo", "downloads/trevo_a010.jar|Trevo a 0.1.0", "downloads/trevo_a013.jar|Trevo a 0.1.3", "downloads/trevo_a015.jar|Trevo a 0.1.5"]}, {"type": "p", "text": ""}], "type": "container", "collaps": true, "show": false}], "collaps": false, "show": false, "wordCount": 1408, "key": "trevo", "languages": ["Java"], "hashtags": ["trevo", "java", "sixgen", "geneticalgorithm", "2dgraphics"], "date": "09-01-2020", "section": "main"}, "snip-boids": {"title": "Boids", "content": [{"title": null, "content": [{"type": "p", "text": "Boids is a simple flocking algorithm based on:"}, {"type": "ul", "items": ["separation - separate from obstacles", "alignment - align with the nearby flock", "cohesion - steer towards the nearby flock."]}, {"type": "p", "text": "More @@here|https://en.wikipedia.org/wiki/Boids@@.\nMade with @@spool@@"}], "type": "container", "collaps": false, "show": false}, {"type": "p", "text": "spacebar - show obstacle vision\nwasd - move the center ball", "title": "Controls", "collaps": false, "show": false}, {"title": "Console", "content": [{"type": "p", "text": "You can change the following constants using browser console:"}, {"type": "ul", "items": ["boidManager.cohesionCoef", "boidManager.alignmentCoef", "boidManager.avoidanceCoef", "boidManager.vision", "boidManager.obstacleVision", "boidManager.obstacleWeight"]}, {"type": "p", "text": "You can play with other parameters on your own discretion.\n"}], "type": "container", "collaps": false, "show": false}], "collaps": false, "show": false, "wordCount": 73, "key": "snip-boids", "languages": ["spool", "js"], "hashtags": ["js", "spool", "snippet", "boids"], "date": "12-03-2020", "section": "snippets"}, "ellatu": {"title": "Ellatu", "content": [{"type": "p", "text": "  Ellatu is a library for creating team based games based on collaboration and text submissions. Elatu is also on @@github|https://github.com/sixkey/ellatu@@ and @@pypi|https://pypi.org/project/ellatu/@@. The documentation is currently not present, maybe in the future. \n  Ellatu primarily focuses on the back-end, but contains a discord-bot front-end. ", "title": "Introduction", "collaps": false, "show": false}, {"title": "Ellatu", "content": [{"type": "p", "text": "    World is a set of connected (each level has a set of prerequisites) levels connected by a theme, testing pipeline or a language. ", "title": "World", "collaps": false, "show": false}, {"type": "p", "text": "    Each level apart from metadata such as title, description, hashtags, prerequisites, etc. contains tests and workflow-id. Workflow-id defines how is the level tested, tests define the test data. For example lists of inputs and outputs. ", "title": "Level", "collaps": false, "show": false}, {"type": "p", "text": "    Ellatu was created with the intention of supporting team based games, meaning we had to separate the act of submitting and running as each team-member has to submit on his own before one can finally run the tests. Each user can submit his set of \"text fragments\". This can be used to limit the number of lines in functions, for example you can limit each user to submit at most three fragments each containing no more than ten lines. ", "title": "Submit", "collaps": false, "show": false}, {"type": "p", "text": "    Once all the answers are submitted, one user can run the answer either alone or with other users by tagging them. ", "title": "Run", "collaps": false, "show": false}], "type": "container", "collaps": false, "show": false}, {"title": "Mapper", "content": [{"type": "p", "text": "  Ellatu currently contains one world (level set), \"mapper\". Mapper is a very simple python-like language (severely stripped down). The main idea is moving a ship on a 2d colored grid. Your task is to draw a map (an image) that satisfies the level's descpription or to replicate a map given by the level. \n  The levels are simple from the start, but get harder as you move one, mainly because there are no composite data structures (no lists, tuples, sets, etc.) so you have to be creative.\n  The following level is a start of a medium difficulty level branch revolving around space invaders. In the first level of this branch, we are drawing only a one character that will in later levels populate a whole scene (you will have to see that for yourself). \n  ::spcinv|images/spcinv1-0-start.png|Space invader level|300::\n  The following level is one in which you are supossed to recolor black path blue, and represent levels that are task driven and contain more tests.\n  ::follow|images/follow-0-start.png|Line following level|300::", "title": null, "collaps": false, "show": false}, {"type": "p", "text": "    The grammar for mapper language is defined in @@EBNF|https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form@@ and the parser is generated using @@Tatsu|https://github.com/neogeny/TatSu@@.", "title": "Grammar", "collaps": false, "show": false}, {"type": "p", "text": "    Runtime is achieved via tatsu walker and is done in python. As the code for mapper is usually no more than 80 lines long and does not contain any complex logic this is relatively fine.", "title": "Runtime", "collaps": false, "show": false}], "type": "container", "collaps": false, "show": false}, {"type": "p", "text": "  Discord bot is currently under development, I shall add link for it once it is at least in a beta stage.\n  I must admit, that the discord interface is a little clumsy as it is basically a terminal. Meaning creation of a usable editor is almost impossible. That being said, it is a matter of an opinion and you should try it for yourself (once the bot is done). \n", "title": "Discord Bot", "collaps": false, "show": false}], "collaps": false, "show": false, "wordCount": 514, "key": "ellatu", "languages": ["python"], "hashtags": ["python", "discord", "tatsu", "grammar", "mongo"], "date": "08-27-2001", "section": "side"}, "sixgen": {"title": "SixGen", "content": [{"type": "p", "text": "SixGen is game engine written in Java.\n\nmore coming soon\n", "title": "Introduction", "collaps": true, "show": true}], "collaps": false, "show": false, "wordCount": 13, "key": "sixgen", "languages": ["java"], "hashtags": ["java", "gameegine", "graphics"], "date": "09-01-2020", "section": "comingsoon"}, "priiivat": {"title": "Priiivat", "content": [{"type": "p", "text": "Priiivat is a simple web-app for roommates. It keeps information about different payments and calculates who owns who.\n\nmore coming soon\n", "title": "Introduction", "collaps": true, "show": true}], "collaps": false, "show": false, "wordCount": 24, "key": "priiivat", "languages": ["mern", "mongo", "express", "react", "node", "js"], "hashtags": ["priiivat", "mern", "mongo", "express", "react", "nodejs"], "date": "09-01-2020", "section": "comingsoon"}, "snip-hunters2": {"title": "Hunters 2", "content": [{"type": "p", "text": "In this snippet, I am evolving simple agents for object finding. ", "title": null, "collaps": false, "show": false}, {"type": "p", "text": "The second version of @@snip-hunters@@. The learning model is more supervised via curated natural selection. Each time hunter eats food, his fitness goes up. The evolution system grabs all hunters after a set period, picks the ones with the highest fitness (i.e. the highest number of eaten food), and populates a new generation by copying and mutating their genes.\nHunters 2 also runs on a new ECS system added in spool2.\n", "title": "Description", "collaps": false, "show": false}], "collaps": false, "show": false, "wordCount": 84, "key": "snip-hunters2", "languages": ["spool", "js"], "hashtags": ["js", "spool", "snippet", "hunters"], "date": "12-03-2020", "section": "snippets"}, "nhi": {"title": "nhi", "content": [{"type": "p", "text": "Nhi is a content rendering solution that translates markdownish files into pages like these.\n\nmore coming soon\n", "title": "Introduction", "collaps": true, "show": true}], "collaps": false, "show": false, "wordCount": 20, "key": "nhi", "languages": ["mern", "mongo", "express", "react", "node", "js"], "hashtags": ["nhi", "mern", "mongo", "express", "react", "node", "js", "html", "css"], "date": "09-01-2020", "section": "comingsoon"}, "snip-cars": {"title": "Cars", "content": [{"type": "p", "text": "The same as @@snip-hunters2@@ except this time they are trying to stay on track.\n"}], "collaps": false, "show": false, "wordCount": 14, "key": "snip-cars", "languages": ["spool", "js"], "hashtags": ["js", "spool", "snippet", "cars", "dnn"], "date": "01-24-2020", "section": "snippets"}, "snip-particles": {"title": "Particles", "content": [{"type": "p", "text": "In this snippet, I am simulating simple particles using @@Lennard-Jones potential|https://en.wikipedia.org/wiki/Lennard-Jones_potential@@. I in no way understand the physics behind intermolecular interaction or nuclear forces. **I used said equations rather liberally**.  ", "title": null, "collaps": false, "show": false}, {"type": "p", "text": "movement - dragging with the left mouse button pressed \nzoom - dragging with the right mouse button pressed ", "title": "Controls", "collaps": false, "show": false}, {"type": "p", "text": "In the original formula, the %%n%% is high (6), so the function is much sharper. That means that the attraction (part of the function below zero) goes away quickly (it becomes negligible). If you lower the %%n%% into the range 1-2, the attraction is present even for higher %%r%%. That usually means that the particles will attract each other no matter the distance. This results in a \"glob\" of particles in the center.\n\nPreset */star*/ is based on a low %%n%% and thus it produces said \"glob\", but an interesting one if I may say so myself. At first, the particles will come together to form a ball or a core. As the core becomes bigger a pressure builds up in the center causing heavier particles to form. The heavier particles not only have larger %%\\sigma%% which means their forces are bigger, but also larger %%\\varepsilon%% so they are more likely to repel. Because of this, they are moved first to the edge, where they form a crust around the core, later they form \"arms\".", "title": "Interesting observations", "collaps": false, "show": false}, {"title": "Simulation", "content": [{"type": "p", "text": "The simulation is simple, for every particle pair on screen, calculate force using function %%f%% where:"}, {"type": "latex", "items": ["f(r) = 4\\varepsilon\\Bigg[\\Big(\\frac{\\sigma}{r}\\Big)^{2n} - \\Big(\\frac{\\sigma}{r}\\Big)^n\\Bigg]"]}, {"type": "p", "text": "%%\\sigma = sC%%\n%%\\varepsilon = eC%% - the point in which the function is equal to zero.\n%%C = \\log_{2}(1 + m_1 + m_2)%% *-This is purely my invention*- \n%%m_1, m_2%% - \"mass\" of particles\n%%n, e, s%% - controlled by sliders\n%%r%% - the distance between two particles", "alignment": "center"}, {"type": "p", "text": "\n"}], "type": "container", "collaps": false, "show": false}], "collaps": false, "show": false, "wordCount": 308, "key": "snip-particles", "languages": ["spool2", "js"], "hashtags": ["js", "spool2", "snippet", "particles"], "date": "12-28-2020", "section": "snippets"}, "scaretycoon": {"title": "Scare Tycoon", "content": [{"type": "p", "text": "Scare Tycoon is a tower defense game made using @@sixgen@@.\n\nmore coming soon\n", "title": "Introduction", "collaps": true, "show": true}, {"title": "Downloads", "content": [{"type": "downloads", "items": ["downloads/ScareTycoonSetup.zip|ScareTycoon"]}, {"type": "p", "text": ""}], "type": "container", "collaps": true, "show": true}], "collaps": false, "show": false, "wordCount": 21, "key": "scaretycoon", "languages": ["java", "sixgen"], "hashtags": ["java", "sixgen", "spongia", "hackaton"], "date": "09-01-2020", "section": "comingsoon"}}, "sections": {"side": {"title": "Current", "posts": ["ellatu"]}, "main": {"title": "Finished", "posts": ["clunk", "trevo"]}, "snippets": {"title": "Snippets", "posts": ["snip-boids", "snip-hunters", "snip-hunters2", "snip-particles", "snip-astar", "snip-cars"]}, "comingsoon": {"title": "Page coming soon", "posts": ["sixgen", "axiol", "spool", "scaretycoon", "nhi", "priiivat", "cah", "lebac"]}}}